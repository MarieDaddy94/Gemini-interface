
const { gemini, GEMINI_AUTOPILOT_MODEL, GEMINI_THINKING_CONFIG } = require("../geminiClient");
const { evaluateProposedTrade } = require("../risk/riskEngine");
const playbookPerformanceService = require("./playbookPerformanceService");
const deskPolicyEngine = require("../services/deskPolicyEngine");
const tiltService = require("../services/tiltService");
const playbookService = require("../services/playbookService"); 

/**
 * Generates a structured trade plan using Gemini.
 */
async function generateAutopilotPlan({
  symbol,
  timeframe,
  mode,
  question,
  brokerSnapshot,
  visionSummary,
  riskProfile,
  notes,
  activePlaybooks // NEW: Array of {name, id} passed from desk state
}) {
  // Fetch Tilt State for context
  const tiltState = await tiltService.getTiltState();
  const defenseContext = `Defense Mode: ${tiltState.defenseMode.toUpperCase()} (${tiltState.riskState}). Signals: ${tiltState.tiltSignals.map(s => s.reason).join(', ') || 'None'}`;

  // If no specific active playbooks passed, fall back to "Any" but prioritize known ones
  const allowedPlaybookNames = activePlaybooks && activePlaybooks.length > 0 
      ? activePlaybooks.map(p => `"${p.name}" (Risk Cap: ${p.riskCapR}R)`).join(', ')
      : "Any valid setup, but PREFER standard playbooks.";

  const systemInstruction = `
You are the lead strategist of an AI trading squad.
Your job:
- Read the account snapshot, risk context, **VISION SNAPSHOTS**, and question.
- Propose ONE structured trade plan as JSON.
- Respect strict risk: never exceed requested risk% or blow daily drawdown.
- **MANDATORY**: You must assign a "playbook" name to this trade.
  **YOU MUST CHOOSE FROM THESE ACTIVE PLAYBOOKS**: [${allowedPlaybookNames}]
  If the trade does not fit one of these, DO NOT TRADE. Return "none" for direction or explain why.

Context:
- Symbol: ${symbol}
- Timeframe: ${timeframe}
- Mode: ${mode}
- Risk Profile: ${riskProfile || "balanced"}
- **DEFENSE CONTEXT**: ${defenseContext}
- **VISION CONTEXT**: ${visionSummary || "No vision data available. Rely on price structure implied by question."}
- Extra Notes: ${notes || "none"}

Account:
- Equity: ${brokerSnapshot?.equity || 0}
- Daily PnL: ${brokerSnapshot?.dailyPnl ?? "n/a"}
- Open Positions: ${brokerSnapshot?.openPositionsCount ?? 0}

User Question/Directive: "${question || "Generate a plan if a setup exists."}"

If Defense Mode is CAUTION, be very selective.
If Defense Mode is DEFENSE or LOCKDOWN, do NOT propose a new trade unless it is explicitly to reduce risk (hedge).

You MUST respond in this exact JSON structure:
{
  "summary": string,
  "rationale": string,
  "riskNotes": string,
  "jsonTradePlan": {
    "direction": "LONG" | "SHORT",
    "symbol": string,
    "entryType": "market" | "limit",
    "entryPrice": number | null,
    "stopLoss": number | null,
    "takeProfits": [{ "level": number, "sizePct": number }],
    "riskPct": number,
    "playbook": string  // MUST BE ONE OF THE ACTIVE PLAYBOOKS
  },
  "checklist": string[],
  "warnings": string[]
}
`;

  try {
    const response = await gemini.models.generateContent({
      model: GEMINI_AUTOPILOT_MODEL,
      contents: [{ role: "user", parts: [{ text: systemInstruction }] }],
      config: {
        responseMimeType: "application/json",
        ...GEMINI_THINKING_CONFIG
      },
    });

    const text = response.text;
    const parsed = JSON.parse(text);
    return parsed;
  } catch (error) {
    console.error("[AutopilotOrchestrator] Generation failed:", error);
    throw new Error("Failed to generate autopilot plan");
  }
}

/**
 * Runs the plan through the Risk Engine AND checks Playbook Performance.
 */
async function reviewAutopilotPlan(plan, sessionState) {
  const tradePlan = plan.jsonTradePlan;
  
  if (!tradePlan || !tradePlan.direction || !tradePlan.riskPct) {
    return {
      allowed: false,
      reasons: ["Invalid plan structure generated by AI."],
      warnings: [],
      plan
    };
  }

  // 0. Fetch Current Desk Policy & Tilt State
  const basePolicy = await deskPolicyEngine.getCurrentPolicy();
  const tiltState = await tiltService.getTiltState();
  const currentPolicy = tiltService.applyDefenseMode(basePolicy, tiltState.defenseMode);

  // 1. Basic Risk Engine Check
  const proposedTrade = {
    direction: tradePlan.direction.toLowerCase(), // 'long' | 'short'
    riskPercent: tradePlan.riskPct,
    comment: plan.summary,
    playbook: tradePlan.playbook
  };

  const riskResult = evaluateProposedTrade(sessionState, proposedTrade, currentPolicy);
  const reasons = [...riskResult.reasons];
  const warnings = [...riskResult.warnings];
  let allowed = riskResult.allowed;

  // 2. Playbook Performance Check
  let playbookProfile = null;
  if (tradePlan.playbook && tradePlan.symbol) {
     playbookProfile = await playbookPerformanceService.getProfileForPlaybook(tradePlan.playbook, tradePlan.symbol);
     
     if (playbookProfile) {
        if (playbookProfile.health === 'red') {
           allowed = false; 
           reasons.push(`Playbook '${tradePlan.playbook}' is marked RED (Health Check Failed).`);
           reasons.push(`Stats: Win ${Math.round(playbookProfile.winRate*100)}%, Avg ${playbookProfile.avgR.toFixed(2)}R.`);
        } else if (playbookProfile.health === 'amber') {
           warnings.push(`Playbook '${tradePlan.playbook}' is AMBER. Proceed with caution.`);
           if (tradePlan.riskPct > 0.25) {
              warnings.push("Risk capped to 0.25% due to Amber health status.");
           }
        }
     } else {
        warnings.push(`New or unknown playbook '${tradePlan.playbook}'. No historical data.`);
     }
  }

  if (tiltState.defenseMode !== 'normal') {
      warnings.push(`Defense Mode Active: ${tiltState.defenseMode.toUpperCase()}. Rules are tightened.`);
  }

  return {
    allowed,
    reasons,
    warnings,
    plan,
    riskDetails: riskResult,
    playbookProfile,
    policyUsed: currentPolicy.id, 
    tiltState 
  };
}

module.exports = {
  generateAutopilotPlan,
  reviewAutopilotPlan
};